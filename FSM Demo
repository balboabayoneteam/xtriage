import uuid
from datetime import datetime
from typing import List, Optional
from fastapi import FastAPI, HTTPException, status # type: ignore
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field, validator

app = FastAPI(title="OneTeam FSM Demo API", version="0.1.0")

# Add CORS middleware for security
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost", "http://localhost:3000", "http://127.0.0.1"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

REQUESTS, VENDORS, BIDS, JOBS = {}, {}, {}, {}

class MaintenanceRequest(BaseModel):
    property_id: str = Field(..., min_length=1, max_length=100, description="Property ID")
    unit: str = Field(..., min_length=1, max_length=50, description="Unit number/identifier")
    category: str = Field(..., min_length=1, max_length=50, description="Request category (plumbing, electrical, etc)")
    urgency: str = Field(..., description="Urgency level")
    description: str = Field(..., min_length=1, max_length=1000, description="Detailed description")
    photos: Optional[List[str]] = Field(None, description="List of photo URLs")
    
    @validator('urgency')
    def validate_urgency(cls, v):
        valid_urgencies = ['low', 'medium', 'high', 'emergency']
        if v.lower() not in valid_urgencies:
            raise ValueError(f'Urgency must be one of {valid_urgencies}')
        return v.lower()

class Vendor(BaseModel):
    name: str = Field(..., min_length=1, max_length=100, description="Vendor name")
    category: List[str] = Field(..., min_items=1, description="Service categories")
    max_cap: float = Field(500.0, gt=0, description="Maximum capacity")
    emergency_cap: float = Field(1000.0, gt=0, description="Emergency capacity")
    
    @validator('category', pre=True, each_item=True)
    def validate_categories(cls, v):
        if not isinstance(v, str) or len(v) == 0:
            raise ValueError('Each category must be a non-empty string')
        return v.lower()

class Bid(BaseModel):
    vendor_id: str = Field(..., description="Vendor ID")
    request_id: str = Field(..., description="Request ID")
    amount: float = Field(..., gt=0, description="Bid amount")
    response: str = Field(..., min_length=1, max_length=500, description="Vendor response")

class DispatchDecision(BaseModel):
    bid_id: str = Field(..., description="Bid ID")
    decision: str = Field(..., description="Approval decision")
    bill_to: str = Field(..., min_length=1, max_length=100, description="Bill to account")

@app.post("/intake", status_code=status.HTTP_201_CREATED)
def intake(req: MaintenanceRequest):
    """Create a new maintenance request"""
    try:
        req_id = str(uuid.uuid4())
        REQUESTS[req_id] = req.dict() | {"id": req_id, "created_at": datetime.utcnow().isoformat(), "status": "open"}
        return {"request_id": req_id, "status": "created"}
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f"Error creating request: {str(e)}")

@app.get("/intake/{request_id}", status_code=status.HTTP_200_OK)
def get_request(request_id: str):
    """Retrieve a maintenance request"""
    if request_id not in REQUESTS:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Request not found")
    return REQUESTS[request_id]

@app.get("/intake", status_code=status.HTTP_200_OK)
def list_requests():
    """List all maintenance requests"""
    return {"requests": list(REQUESTS.values())}

@app.post("/vendors", status_code=status.HTTP_201_CREATED)
def register_vendor(vendor: Vendor):
    """Register a new vendor"""
    try:
        vid = str(uuid.uuid4())
        VENDORS[vid] = vendor.dict() | {"id": vid, "registered_at": datetime.utcnow().isoformat()}
        return {"vendor_id": vid, "status": "registered"}
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f"Error registering vendor: {str(e)}")

@app.get("/vendors/{vendor_id}", status_code=status.HTTP_200_OK)
def get_vendor(vendor_id: str):
    """Retrieve vendor details"""
    if vendor_id not in VENDORS:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Vendor not found")
    return VENDORS[vendor_id]

@app.get("/vendors", status_code=status.HTTP_200_OK)
def list_vendors():
    """List all vendors"""
    return {"vendors": list(VENDORS.values())}

@app.get("/vet/{request_id}", status_code=status.HTTP_200_OK)
def vet(request_id: str):
    """Vet vendors qualified for a maintenance request"""
    if request_id not in REQUESTS:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Request not found")
    req = REQUESTS[request_id]
    vetted = [{"vendor_id": vid, "name": v["name"], "categories": v["category"], "max_cap": v["max_cap"], "emergency_cap": v["emergency_cap"]} for vid, v in VENDORS.items() if req["category"] in v["category"]]
    return {"request_id": request_id, "vetted_vendors": vetted, "count": len(vetted)}

@app.post("/bid", status_code=status.HTTP_201_CREATED)
def bid(bid_data: Bid):
    """Submit a bid for a maintenance request"""
    if bid_data.request_id not in REQUESTS or bid_data.vendor_id not in VENDORS:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Request or Vendor not found")
    
    vendor = VENDORS[bid_data.vendor_id]
    request = REQUESTS[bid_data.request_id]
    
    # Validate bid amount against vendor capacity
    max_amount = vendor["emergency_cap"] if request["urgency"] == "emergency" else vendor["max_cap"]
    if bid_data.amount > max_amount:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f"Bid amount exceeds vendor capacity of {max_amount}")
    
    bid_id = str(uuid.uuid4())
    BIDS[bid_id] = bid_data.dict() | {"id": bid_id, "created_at": datetime.utcnow().isoformat(), "status": "pending"}
    return {"bid_id": bid_id, "status": "submitted"}

@app.get("/bid/{bid_id}", status_code=status.HTTP_200_OK)
def get_bid(bid_id: str):
    """Retrieve bid details"""
    if bid_id not in BIDS:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Bid not found")
    return BIDS[bid_id]

@app.get("/bids", status_code=status.HTTP_200_OK)
def list_bids():
    """List all bids"""
    return {"bids": list(BIDS.values())}

@app.post("/dispatch", status_code=status.HTTP_200_OK)
def dispatch(decision: DispatchDecision):
    """Dispatch a job based on a bid decision"""
    if decision.bid_id not in BIDS:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Bid not found")
    
    bid = BIDS[decision.bid_id]
    
    if decision.decision.lower() not in ['approved', 'rejected', 'pending']:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Decision must be 'approved', 'rejected', or 'pending'")
    
    if decision.decision.lower() == 'rejected':
        BIDS[decision.bid_id]['status'] = 'rejected'
        return {"status": "rejected", "bid_id": decision.bid_id}
    
    job_id = str(uuid.uuid4())
    JOBS[job_id] = {
        "job_id": job_id,
        "request_id": bid["request_id"],
        "vendor_id": bid["vendor_id"],
        "amount": bid["amount"],
        "bill_to": decision.bill_to,
        "status": "dispatched",
        "created_at": datetime.utcnow().isoformat(),
        "decision": decision.decision.lower()
    }
    BIDS[decision.bid_id]['status'] = decision.decision.lower()
    return {"status": "approved", "job_id": job_id, "job": JOBS[job_id]}

@app.get("/jobs/{job_id}", status_code=status.HTTP_200_OK)
def job_status(job_id: str):
    """Retrieve job status"""
    if job_id not in JOBS:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Job not found")
    return JOBS[job_id]

@app.get("/jobs", status_code=status.HTTP_200_OK)
def list_jobs():
    """List all jobs"""
    return {"jobs": list(JOBS.values())}

@app.patch("/jobs/{job_id}", status_code=status.HTTP_200_OK)
def update_job_status(job_id: str, status_update: dict):
    """Update job status"""
    if job_id not in JOBS:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Job not found")
    
    valid_statuses = ['dispatched', 'in_progress', 'completed', 'cancelled']
    new_status = status_update.get('status', '').lower()
    
    if new_status not in valid_statuses:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f"Status must be one of {valid_statuses}")
    
    JOBS[job_id]['status'] = new_status
    JOBS[job_id]['updated_at'] = datetime.utcnow().isoformat()
    return JOBS[job_id]

@app.get("/health", status_code=status.HTTP_200_OK)
def health_check():
    """API health check"""
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "requests": len(REQUESTS),
        "vendors": len(VENDORS),
        "bids": len(BIDS),
        "jobs": len(JOBS)
    }
